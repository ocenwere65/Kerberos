I used the Java programming language when constructing the program. For socket programming, user input, and scanner, I imported the java.io and java.util libraries. For the encryption/decryption implementation, I imported the java.crypto and java.security libraries. And Lastly, to declare/initialize the HMAC key, I imported the static hmac libraries.
The IDE I used was Netbeans.
I broke up the project into multiple tasks and would build upon the program incrementally through assessing the functionality of each task. First, I initialized the DES and HMAC keys and dumped them into a shared text file for both the Client and the Server to access. Once that ask is complete, I established the socket connection between the Client and the Server, similar to the previous lab. Then, I have the Client input a message and have the text encrypted in a multi-faceted process: I encrypted the message using the HMAC key, concatenate the encryption to the plaintext and encrypt the concatenation using the DES key. Finally, I sent the encrypted text to server to decrypt. Like in the previous lab, I first converted the encrypted text from the byte format to hex format before sending it to Server. Once the Server receives the encrypted text, I decrypt it (using the same DES decryption method I used in Lab 1) to obtain the concatenation. I had a little trouble un-concatenating the plaintext from the HMAC encryption. I first tried separating through punctuation marks but this would operate under the assumption that the HMAC didn’t also contain punctuations. I ultimately decided on creating a third shared text file that contains the length of the plaintext message (before encryption) for the receiver to read from. Using the index, I break the concatenation into two strings, one containing the plaintext and the other containing the HMAC. Lastly, I encrypted the obtained plaintext using the HMAC key in Server and, after compare the newly constructed key to the obtained HMAC key, verify whether the keys are the same. Once all of these functions work properly, I had to make the communication bi-directional; To do this, I simply reversed the process by encrypting the Server’s response and having the Client decrypt it using the same methods (with a few alterations). Finally, in both Client and Server, I placed an infinite while loop that will only break when the Client types “Goodbye” as a response.
